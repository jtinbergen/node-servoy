import * as os from 'os';
import * as uuid from 'uuid';
import { spawn } from 'child_process';
import { LOGGINGLEVEL, APPLICATION_TYPES } from './constants';

const execProgram = async (cmd: string, args: string, options: any): Promise<string> =>
    new Promise((resolve, reject) => {
        let stdout = '';
        let stderr = '';
        const childprocess = spawn(cmd, args.split(' '), options);
        childprocess.stdout.on('data', (data) => {
            stdout += data.toString();
        });

        childprocess.stderr.on('data', (data) => {
            stderr += data.toString();
        });

        childprocess.on('close', (code) => {
            const result = { code, stdout, stderr };
            if (code !== 0) {
                return reject(JSON.stringify(result));
            }

            return resolve(JSON.stringify(result));
        });
    });

/**
 * Execute a program and returns output. Specify the cmd as you would do in a console.
 * @param program Full path of the program to execute.
 * @param params An array of strings as program arguments.
 * @param environmentVars Array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
 * @param cwd The working directory of the subprocess, or null if the subprocess should inherit the working directory of the current process.
 * @returns {string} The output generated by the program execution.
 */
const executeProgram = async (
    program: string,
    params: string,
    environmentVars: string[],
    cwd: any,
): Promise<string> => {
    const env: any = {};
    environmentVars.forEach((variable) => {
        const parts = variable.split('=');
        env[parts[0]] = parts[1];
    });

    return execProgram(program, params, {
        env,
        cwd,
    });
};

/**
 * Execute a program in the background. Specify the cmd as you would do in a console.
 * @param program Full path of the program to execute.
 * @param params An array of strings as program arguments.
 * @param environmentVars Array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
 * @param cwd The working directory of the subprocess, or null if the subprocess should inherit the working directory of the current process.
 * @returns {string} The output generated by the program execution.
 */
const executeProgramInBackground = (
    program: string,
    params: string,
    environmentVars: string[],
    cwd: any,
) => {
    const env: any = {};
    environmentVars.forEach((variable) => {
        const parts = variable.split('=');
        env[parts[0]] = parts[1];
    });

    execProgram(program, params, {
        env,
        cwd,
    });
};

/**
 * Stop and exit application.
 */
const exit = () => {
    process.exit();
};

/**
 * Get the application type.
 * @returns {number} Constant application type.
 */
const getApplicationType = (): number => APPLICATION_TYPES.HEADLESS_CLIENT;

/**
 * Get the name of the localhost.
 * @returns {string} Name of the localhost.
 */
const getHostName = (): string => os.hostname();

/**
 * Returns the name of the operating system of the client.
 * @returns {string} Name of the operating system of the client.
 */
const getOSName = (): string => os.type();

/**
 * Returns a date object initialized on server with current date and time.
 * @returns {Date} Server time.
 */
const getServerTimeStamp = (): Date => new Date();

/**
 * Gets the HTTP server URL.
 * @returns {string} The HTTP server URL.
 */
const getServerURL = (): string => `http://${os.hostname()}`;

/**
 * Returns the name of the current solution.
 * @returns {string} Current solution name.
 */
const getSolutionName = (): string => 'node-servoy';

/**
 * Get the solution release number.
 * @returns {number} Current solution release number.
 */
const getSolutionRelease = (): number => 1;

/**
 * Returns a new Date object representing the current date and time.
 * @returns {Date} A Date object representing the current date and time.
 */
const getTimeStamp = (): Date => new Date();

/**
 * Get a new UUID object (also known as GUID) or convert the parameter (that can be string or byte array) to an UUID object.
 * @param arg Optional string or byte array to convert to an UUID.
 * @returns String and byte array representing an UUID.
 */
const getUUID = (arg: string): { toString: () => string; toBytes: () => ArrayBuffer } => {
    const uuidString = arg || uuid.v4();
    const uuidBuffer = Buffer.from(uuidString);
    return {
        toString: () => uuidString,
        toBytes: () => uuidBuffer,
    };
};

/**
 * Returns the application version.
 * @returns {string} Application version.
 */
const getVersion = (): string => '1';

/**
 * Returns true if the solution is running in the developer.
 * @returns {boolean} True if the solution is running in the developer, false otherwise.
 */
const isInDeveloper = (): boolean => false;

/**
 * Output something on the out stream.
 * @param msg Object to send to output stream.
 * @param level The log level where it should log to.
 */
const output = (msg: any, level: LOGGINGLEVEL) => {
    switch (level) {
        case LOGGINGLEVEL.DEBUG:
        case LOGGINGLEVEL.INFO:
            console.log(msg);
            break;
        case LOGGINGLEVEL.WARNING:
            console.warn(msg);
            break;
        case LOGGINGLEVEL.ERROR:
            console.error(msg);
            break;
        default:
            console.log(msg);
    }
};

/**
 * Sleep for specified time (in milliseconds).
 * @param ms Sleep time in milliseconds.
 */
const sleep = (ms: number): Promise<number> => new Promise((resolve) => setTimeout(resolve, ms));

export {
    executeProgram,
    executeProgramInBackground,
    exit,
    getApplicationType,
    getHostName,
    getOSName,
    getServerTimeStamp,
    getServerURL,
    getSolutionName,
    getSolutionRelease,
    getTimeStamp,
    getUUID,
    getVersion,
    isInDeveloper,
    output,
    sleep,
};
